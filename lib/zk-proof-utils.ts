import type { LaceWalletSession } from "@/lib/lace-wallet"

/**
 * ZK Proof utilities for age verification
 * These functions generate and verify zero-knowledge proofs that prove age >= 18
 * without revealing the actual age value
 */

const PROOF_SERVER_URL = process.env.NEXT_PUBLIC_MIDNIGHT_PROOF_SERVER ?? "https://lace-dev.proof-pub.stg.midnight.tools"

export interface AgeProof {
  proof: string // Serialized proof
  commitment: string // Age credential commitment
  statement: "age >= 18" // The statement being proven
  timestamp: string
  expiresAt?: string
}

export interface ProofVerificationResult {
  verified: boolean
  isAdult: boolean
  reason?: string
  proof?: AgeProof
}

/**
 * Generate a ZK proof that proves age >= 18 without revealing the actual age
 * 
 * @param session - Lace wallet session
 * @param commitment - Age credential commitment
 * @param isAdult - Private: whether user is an adult (this value is never exposed)
 * @returns ZK proof that can be verified without revealing isAdult
 */
export async function generateAgeProof(
  session: LaceWalletSession,
  commitment: string,
  isAdult: boolean,
): Promise<AgeProof | null> {
  try {
    // In a real implementation, this would:
    // 1. Create a proof statement: "isAdult == true" (if isAdult is true)
    // 2. Use Midnight's proof server to generate a ZK proof
    // 3. Return the serialized proof
    
    // For now, we'll create a proof structure that includes:
    // - The commitment (public)
    // - A proof signature (would be generated by proof server)
    // - The statement being proven
    
    // Note: The actual proof generation would use Midnight's proof server API
    // This is a placeholder that demonstrates the structure
    
    const proofData = {
      commitment,
      statement: "age >= 18",
      isAdult, // This is private and should be in the proof, not exposed
      timestamp: new Date().toISOString(),
    }
    
    // In production, this would call the proof server to generate the actual proof
    // For now, we'll create a proof reference that can be verified
    const proofReference = await generateProofReference(proofData, isAdult)
    
    return {
      proof: proofReference, // Serialized proof (would be actual ZK proof in production)
      commitment,
      statement: "age >= 18",
      timestamp: proofData.timestamp,
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year expiry
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to generate age proof", error)
    return null
  }
}

/**
 * Verify a ZK proof that proves age >= 18
 * 
 * @param proof - The ZK proof to verify
 * @param commitment - The age credential commitment
 * @returns Verification result indicating if proof is valid and proves age >= 18
 */
export async function verifyAgeProof(
  proof: AgeProof,
  commitment: string,
): Promise<ProofVerificationResult> {
  try {
    // Verify commitment matches
    if (proof.commitment !== commitment) {
      return {
        verified: false,
        isAdult: false,
        reason: "Commitment mismatch",
      }
    }
    
    // Verify proof hasn't expired
    if (proof.expiresAt && new Date(proof.expiresAt) < new Date()) {
      return {
        verified: false,
        isAdult: false,
        reason: "Proof expired",
      }
    }
    
    // In production, this would:
    // 1. Deserialize the proof
    // 2. Use Midnight's verifier to verify the proof
    // 3. Check that the proof statement is "age >= 18"
    // 4. Return verification result
    
    // For now, we'll verify the proof reference structure
    const isValid = await verifyProofReference(proof.proof, commitment)
    
    if (!isValid) {
      return {
        verified: false,
        isAdult: false,
        reason: "Invalid proof structure",
      }
    }
    
    // If proof is valid, it proves age >= 18
    return {
      verified: true,
      isAdult: true, // Proof verification confirms age >= 18
      proof,
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to verify age proof", error)
    return {
      verified: false,
      isAdult: false,
      reason: "Verification error",
    }
  }
}

/**
 * Generate a proof reference (placeholder for actual ZK proof generation)
 * In production, this would call Midnight's proof server
 */
async function generateProofReference(proofData: any, isAdult: boolean): Promise<string> {
  // In production, this would:
  // 1. Create a proof statement circuit
  // 2. Call Midnight proof server to generate proof
  // 3. Return serialized proof
  
  // For now, create a proof reference hash
  const proofPayload = JSON.stringify({
    commitment: proofData.commitment,
    statement: proofData.statement,
    timestamp: proofData.timestamp,
    // Note: isAdult is NOT included in the proof reference
    // It's only used to generate the proof, not stored
  })
  
  const hashBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(proofPayload))
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")
  
  return `zk-proof:${hashHex}`
}

/**
 * Verify a proof reference (placeholder for actual ZK proof verification)
 * In production, this would use Midnight's verifier
 */
async function verifyProofReference(proofReference: string, commitment: string): Promise<boolean> {
  // In production, this would:
  // 1. Deserialize the proof
  // 2. Use Midnight verifier to verify
  // 3. Check proof statement
  
  // For now, verify the proof reference format
  if (!proofReference.startsWith("zk-proof:")) {
    return false
  }
  
  // In a real implementation, we would verify the actual ZK proof here
  // using Midnight's verifier API or local verifier
  
  return true
}

/**
 * Store proof in a way that can be retrieved for verification
 * Stores both client-side (localStorage) and server-side (proof store)
 */
export async function storeAgeProof(proof: AgeProof, subjectKey: string): Promise<void> {
  // Store client-side for local access
  if (typeof window !== "undefined") {
    try {
      const storageKey = `zk-proof:${subjectKey}`
      window.localStorage.setItem(storageKey, JSON.stringify(proof))
    } catch (error) {
      console.warn("[zk-proof-utils] Failed to store proof in localStorage", error)
    }
  }
  
  // Store server-side via API endpoint so verification endpoint can access it
  try {
    const storeUrl = "/api/kyc/store-proof"
    await fetch(storeUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        subjectKey,
        proof,
      }),
    }).catch((error) => {
      console.warn("[zk-proof-utils] Failed to store proof server-side", error)
    })
  } catch (error) {
    console.warn("[zk-proof-utils] Failed to store proof server-side", error)
  }
}

/**
 * Retrieve stored proof for verification
 */
export async function retrieveAgeProof(subjectKey: string): Promise<AgeProof | null> {
  if (typeof window === "undefined") {
    return null
  }
  
  try {
    const storageKey = `zk-proof:${subjectKey}`
    const stored = window.localStorage.getItem(storageKey)
    if (!stored) {
      return null
    }
    return JSON.parse(stored) as AgeProof
  } catch (error) {
    console.warn("[zk-proof-utils] Failed to retrieve proof", error)
    return null
  }
}

// ============================================================================
// Country Proof Utilities
// ============================================================================

export interface CountryProof {
  proof: string // Serialized proof
  commitment: string // Country credential commitment
  statement: "country == France" | "country != France" // The statement being proven
  timestamp: string
  expiresAt?: string
}

export interface CountryProofVerificationResult {
  verified: boolean
  isFrance: boolean
  reason?: string
  proof?: CountryProof
}

/**
 * Generate a ZK proof that proves country == France without revealing the actual country
 */
export async function generateCountryProof(
  session: LaceWalletSession,
  commitment: string,
  isFrance: boolean,
): Promise<CountryProof | null> {
  try {
    const proofData = {
      commitment,
      statement: isFrance ? "country == France" : "country != France",
      isFrance, // This is private and should be in the proof, not exposed
      timestamp: new Date().toISOString(),
    }
    
    const proofReference = await generateCountryProofReference(proofData, isFrance)
    
    return {
      proof: proofReference,
      commitment,
      statement: isFrance ? "country == France" : "country != France",
      timestamp: proofData.timestamp,
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to generate country proof", error)
    return null
  }
}

/**
 * Store a country proof client-side and server-side
 * Similar to storeAgeProof but for country proofs
 */
export async function storeCountryProof(proof: CountryProof, subjectKey: string): Promise<void> {
  // Store client-side for local access
  if (typeof window !== "undefined") {
    try {
      const storageKey = `zk-proof:${subjectKey}:country`
      window.localStorage.setItem(storageKey, JSON.stringify(proof))
    } catch (error) {
      console.warn("[zk-proof-utils] Failed to store country proof in localStorage", error)
    }
  }
  
  // Store server-side via API endpoint so verification endpoint can access it
  try {
    const storeUrl = "/api/kyc/store-proof"
    await fetch(storeUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        subjectKey: `${subjectKey}:country`, // Use country suffix for retrieval
        proof,
      }),
    }).catch((error) => {
      console.warn("[zk-proof-utils] Failed to store country proof server-side", error)
    })
  } catch (error) {
    console.warn("[zk-proof-utils] Failed to store country proof server-side", error)
  }
}

/**
 * Verify a ZK proof that proves country == France
 */
export async function verifyCountryProof(
  proof: CountryProof,
  commitment: string,
): Promise<CountryProofVerificationResult> {
  try {
    if (proof.commitment !== commitment) {
      return {
        verified: false,
        isFrance: false,
        reason: "Commitment mismatch",
      }
    }
    
    if (proof.expiresAt && new Date(proof.expiresAt) < new Date()) {
      return {
        verified: false,
        isFrance: false,
        reason: "Proof expired",
      }
    }
    
    const isValid = await verifyCountryProofReference(proof.proof, commitment)
    
    if (!isValid) {
      return {
        verified: false,
        isFrance: false,
        reason: "Invalid proof structure",
      }
    }
    
    // If proof is valid and statement is "country == France", then isFrance is true
    const isFrance = proof.statement === "country == France"
    
    return {
      verified: true,
      isFrance,
      proof,
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to verify country proof", error)
    return {
      verified: false,
      isFrance: false,
      reason: "Verification error",
    }
  }
}

async function generateCountryProofReference(proofData: any, isFrance: boolean): Promise<string> {
  const proofPayload = JSON.stringify({
    commitment: proofData.commitment,
    statement: proofData.statement,
    timestamp: proofData.timestamp,
  })
  
  const hashBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(proofPayload))
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")
  
  return `zk-proof:country:${hashHex}`
}

async function verifyCountryProofReference(proofReference: string, commitment: string): Promise<boolean> {
  if (!proofReference.startsWith("zk-proof:country:")) {
    return false
  }
  
  return true
}

// ============================================================================
// CAPTCHA Proof Utilities
// ============================================================================

export interface CaptchaProof {
  proof: string // Serialized proof
  commitment: string // Human credential commitment
  statement: "captcha == passed" | "captcha == failed" // The statement being proven
  timestamp: string
  expiresAt?: string
}

export interface CaptchaProofVerificationResult {
  verified: boolean
  captchaPassed: boolean
  reason?: string
  proof?: CaptchaProof
}

/**
 * Generate a ZK proof that proves CAPTCHA passed without revealing the actual result
 */
export async function generateCaptchaProof(
  session: LaceWalletSession,
  commitment: string,
  captchaPassed: boolean,
): Promise<CaptchaProof | null> {
  try {
    const proofData = {
      commitment,
      statement: captchaPassed ? "captcha == passed" : "captcha == failed",
      captchaPassed, // This is private and should be in the proof, not exposed
      timestamp: new Date().toISOString(),
    }
    
    const proofReference = await generateCaptchaProofReference(proofData, captchaPassed)
    
    return {
      proof: proofReference,
      commitment,
      statement: captchaPassed ? "captcha == passed" : "captcha == failed",
      timestamp: proofData.timestamp,
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to generate CAPTCHA proof", error)
    return null
  }
}

/**
 * Store a CAPTCHA proof client-side and server-side
 * Similar to storeAgeProof and storeCountryProof but for CAPTCHA proofs
 */
export async function storeCaptchaProof(proof: CaptchaProof, subjectKey: string): Promise<void> {
  // Store client-side for local access
  if (typeof window !== "undefined") {
    try {
      const storageKey = `zk-proof:${subjectKey}:captcha`
      window.localStorage.setItem(storageKey, JSON.stringify(proof))
    } catch (error) {
      console.warn("[zk-proof-utils] Failed to store CAPTCHA proof in localStorage", error)
    }
  }
  
  // Store server-side via API endpoint so verification endpoint can access it
  try {
    const storeUrl = "/api/kyc/store-proof"
    await fetch(storeUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        subjectKey: `${subjectKey}:captcha`, // Use captcha suffix for retrieval
        proof,
      }),
    }).catch((error) => {
      console.warn("[zk-proof-utils] Failed to store CAPTCHA proof server-side", error)
    })
  } catch (error) {
    console.warn("[zk-proof-utils] Failed to store CAPTCHA proof server-side", error)
  }
}

/**
 * Verify a ZK proof that proves CAPTCHA passed
 */
export async function verifyCaptchaProof(
  proof: CaptchaProof,
  commitment: string,
): Promise<CaptchaProofVerificationResult> {
  try {
    if (proof.commitment !== commitment) {
      return {
        verified: false,
        captchaPassed: false,
        reason: "Commitment mismatch",
      }
    }
    
    if (proof.expiresAt && new Date(proof.expiresAt) < new Date()) {
      return {
        verified: false,
        captchaPassed: false,
        reason: "Proof expired",
      }
    }
    
    const isValid = await verifyCaptchaProofReference(proof.proof, commitment)
    
    if (!isValid) {
      return {
        verified: false,
        captchaPassed: false,
        reason: "Invalid proof structure",
      }
    }
    
    // If proof is valid and statement is "captcha == passed", then captchaPassed is true
    const captchaPassed = proof.statement === "captcha == passed"
    
    return {
      verified: true,
      captchaPassed,
      proof,
    }
  } catch (error) {
    console.error("[zk-proof-utils] Failed to verify CAPTCHA proof", error)
    return {
      verified: false,
      captchaPassed: false,
      reason: "Verification error",
    }
  }
}

async function generateCaptchaProofReference(proofData: any, captchaPassed: boolean): Promise<string> {
  const proofPayload = JSON.stringify({
    commitment: proofData.commitment,
    statement: proofData.statement,
    timestamp: proofData.timestamp,
  })
  
  const hashBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(proofPayload))
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("")
  
  return `zk-proof:captcha:${hashHex}`
}

async function verifyCaptchaProofReference(proofReference: string, commitment: string): Promise<boolean> {
  if (!proofReference.startsWith("zk-proof:captcha:")) {
    return false
  }
  
  return true
}

